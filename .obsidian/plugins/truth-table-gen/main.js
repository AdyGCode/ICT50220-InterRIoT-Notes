/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TruthTablePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// InputModal.ts
var import_obsidian = require("obsidian");
var InputModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Enter logical expression & variables:" });
    new import_obsidian.Setting(contentEl).setName("Expression").setDesc("Please use JS logic symbols: && = and, || = or, ! = negation. (ex. !a&&b||c)").addText(
      (text) => text.onChange((value) => {
        this.result = value;
      })
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result.toLowerCase().replace(/\s+/g, ""));
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// utils.ts
var _Utils = class {
  // You get it.
  static isLetter(s) {
    return s.toLowerCase() != s.toUpperCase();
  }
  static isValidCase(exp, vars2) {
    exp = exp.replace(/\s+/g, "");
    exp = exp.toLowerCase();
    const validatedIndices = /* @__PURE__ */ new Map();
    let openParen = 0;
    let closeParen = 0;
    if (exp.length == 0)
      return false;
    for (let i = 0; i < exp.length; i++) {
      if (i == exp.length - 1 && (exp.charAt(i) == "&" || exp.charAt(i) == "!" || exp.charAt(i) == "|")) {
        return false;
      } else if (exp.charAt(i) == "(") {
        openParen++;
        let closure = false;
        for (let j = i; j < exp.length; j++) {
          const char = exp.charAt(j);
          if (char == ")")
            closure = true;
        }
        if (!closure)
          return false;
      } else if (exp.charAt(i) == ")") {
        closeParen++;
      } else if (validatedIndices.get(i) != true) {
        if (_Utils.isLetter(exp.charAt(i)) && vars2.includes(exp.charAt(i))) {
          try {
            if (!_Utils.isLetter(exp.charAt(i + 1))) {
              validatedIndices.set(i, true);
            } else
              return false;
          } catch (error) {
            return false;
          }
        } else if (exp.charAt(i) === "&" && (exp.charAt(i - 1) != "&" && exp.charAt(i - 1) != "|")) {
          try {
            if (exp.charAt(i + 1) === "&") {
              validatedIndices.set(i, true);
              validatedIndices.set(i + 1, true);
            } else
              return false;
          } catch (error) {
            return false;
          }
        } else if (exp.charAt(i) === "|" && (exp.charAt(i - 1) != "&" && exp.charAt(i - 1) != "|")) {
          try {
            if (exp.charAt(i + 1) === "|") {
              validatedIndices.set(i, true);
              validatedIndices.set(i + 1, true);
            } else
              return false;
          } catch (error) {
            return false;
          }
        } else if (exp.charAt(i) === "!") {
          try {
            if (_Utils.isLetter(exp.charAt(i + 1))) {
              validatedIndices.set(i, true);
              validatedIndices.set(i + 1, true);
            } else if (exp.charAt(i + 1) == "(") {
              validatedIndices.set(i, true);
            } else
              return false;
          } catch (error) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    if (openParen == closeParen) {
      return true;
    } else {
      return false;
    }
  }
  static evaluateTruth(vals, expression, vars) {
    let parsed = expression;
    for (const char of expression) {
      const i = vars.indexOf(char);
      if (i !== -1) {
        parsed = parsed.replace(char, String(vals[i]));
      }
    }
    return eval(parsed);
  }
  static extractVars(e) {
    const vars2 = [];
    for (let i = 0; i < e.length; i++) {
      const char = e.charAt(i);
      if (_Utils.isLetter(char)) {
        vars2.push(char);
      }
    }
    return vars2;
  }
  static allCombinations(num) {
    const combinations = [];
    for (let i = 0; i < 1 << num; i++) {
      const combination = [];
      for (let j = num - 1; j >= 0; j--) {
        combination.push((i & 1 << j) !== 0);
      }
      combinations.push(combination);
    }
    return combinations;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  latex: true,
  binary: false
};
var TruthTablePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    console.log("Loading Truth Table+");
    this.addCommand({
      id: "generate-truth-table",
      name: "Generate truth table",
      // Creating a new modal to get expression, runs createTruthTable on submit
      editorCallback: (editor, view) => new InputModal(this.app, (exp) => this.createTruthTable(view, exp)).open()
    });
    this.addSettingTab(new SettingTab(this.app, this));
  }
  onunload() {
    console.log("Unloading Truth Table+");
  }
  // Pulls user settings from memory
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  // Puts user settings to memory
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Will always be called when the modal is submitted
  createTruthTable(activeView, e) {
    if (activeView) {
      const editor = activeView.editor;
      const truthTable = this.generateTruthTable(e, _Utils.extractVars(e));
      editor.replaceSelection(truthTable);
    } else {
      console.error("No active markdown view found");
    }
  }
  // Is only ever called by the above
  generateTruthTable(expression2, vars2) {
    if (_Utils.isValidCase(expression2, vars2)) {
      const combinations = _Utils.allCombinations(vars2.length);
      let table;
      if (this.settings.latex == true) {
        let latexExpression = ``;
        for (let i = 0; i < expression2.length; i++) {
          if (_Utils.isLetter(expression2.charAt(i)) || expression2.charAt(i) == "(" || expression2.charAt(i) == ")") {
            latexExpression = latexExpression + expression2.charAt(i);
          } else if (expression2.charAt(i) == "&") {
            latexExpression += " \\wedge ";
            i++;
          } else if (expression2.charAt(i) == "|") {
            latexExpression += " \\lor ";
            i++;
          } else if (expression2.charAt(i) == "!") {
            latexExpression += " \\neg ";
          }
        }
        latexExpression = `$` + latexExpression + `$`;
        table = `| ${vars2.join(" | ")} | ${latexExpression} |
`;
      } else {
        let modifiedExp = "";
        for (const x of expression2) {
          if (x == "|") {
            modifiedExp += "\\|";
          } else {
            modifiedExp += x;
          }
        }
        table = `| ${vars2.join(" | ")} | ${modifiedExp} |
`;
      }
      table += `| ${"-|".repeat(vars2.length)}-|
`;
      for (let i = 0; i < combinations.length; i++) {
        const vals2 = [];
        for (let j = 0; j < vars2.length; j++) {
          vals2.push(combinations[i][j]);
        }
        try {
          const truth = _Utils.evaluateTruth(vals2, expression2, vars2);
          if (this.settings.binary) {
            const numVals = [];
            for (const x of vals2) {
              numVals.push(Number(x));
            }
            table += `| ${numVals.join(" | ")} | ${Number(truth)} |
`;
          } else {
            const stringVals = [];
            for (const x of vals2) {
              stringVals.push(String(x).charAt(0).toUpperCase() + String(x).slice(1));
            }
            table += `| ${stringVals.join(" | ")} | ${String(truth).charAt(0).toUpperCase() + String(truth).slice(1)} |
`;
          }
        } catch (error) {
          new import_obsidian2.Notice("Something went wrong. \n Error: " + error);
          return "";
        }
      }
      return table;
    } else {
      new import_obsidian2.Notice("Your logic expression was invalid. Please try again.", 5e3);
      return "";
    }
  }
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Use math blocks and symbols for entries and header.").setDesc("When off will use default JS logic symbols (i.e. &&, ||, !).").addToggle((toggle) => toggle.setValue(this.plugin.settings.latex === true).onChange(async (value) => {
      this.plugin.settings.latex = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Output true/false values as binary.").setDesc("When on 1 = true, 0 = false.").addToggle((toggle) => toggle.setValue(this.plugin.settings.binary === true).onChange(async (value) => {
      this.plugin.settings.binary = value;
      await this.plugin.saveSettings();
    }));
  }
};
